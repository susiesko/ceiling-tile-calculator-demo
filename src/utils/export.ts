import { AppState, ExportData } from '../types';

export function exportConfiguration(state: AppState): void {
  const exportData: ExportData = {
    configuration: {
      units: state.units,
      shape: state.shape,
      cutouts: state.cutouts,
      tileConfig: state.tileConfig,
      gridConfig: state.gridConfig,
      pricePerTile: state.pricePerTile
    },
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  };

  const blob = new Blob([JSON.stringify(exportData, null, 2)], {
    type: 'application/json'
  });

  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `ceiling-tile-config-${new Date().toISOString().split('T')[0]}.json`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

export function exportCanvasAsPNG(canvas: HTMLCanvasElement, filename?: string): void {
  const link = document.createElement('a');
  link.download = filename || `ceiling-tile-layout-${new Date().toISOString().split('T')[0]}.png`;
  link.href = canvas.toDataURL('image/png');
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

export function importConfiguration(file: File): Promise<ExportData> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = (event) => {
      try {
        const content = event.target?.result as string;
        const data = JSON.parse(content) as ExportData;

        // Basic validation
        if (!data.configuration || !data.timestamp || !data.version) {
          throw new Error('Invalid configuration file format');
        }

        resolve(data);
      } catch (error) {
        reject(new Error('Failed to parse configuration file: ' + (error as Error).message));
      }
    };

    reader.onerror = () => {
      reject(new Error('Failed to read file'));
    };

    reader.readAsText(file);
  });
}

export function generateShoppingList(state: AppState): string {
  const { calculation, tileConfig, units } = state;
  const unitLabel = 'sq ft';
  const tileLabel = tileConfig.size === '2x2' ? '2×2' : '2×4';

  let list = 'Ceiling Tile Shopping List\n';
  list += '=========================\n\n';

  list += `Room Area: ${calculation.area.toFixed(1)} ${unitLabel}\n`;
  list += `Tile Size: ${tileLabel} feet\n`;
  list += `Tile Orientation: ${tileConfig.orientation}°\n\n`;

  list += 'Tiles Needed:\n';
  list += `• Full tiles: ${calculation.fullTiles.toLocaleString()}\n`;
  list += `• Partial tiles: ${calculation.partialTiles.toLocaleString()}\n`;
  list += `• Total recommended: ${calculation.estimatedTotal.toLocaleString()}\n`;
  list += `• Waste factor: ${calculation.wasteFactor.toFixed(1)}%\n\n`;

  if (tileConfig.enableBorder && tileConfig.borderWidth > 0) {
    list += `Border width: ${tileConfig.borderWidth} feet\n\n`;
  }

  if (calculation.costEstimate) {
    list += `Estimated cost: $${calculation.costEstimate.toFixed(2)}\n\n`;
  }

  list += 'Additional items to consider:\n';
  list += '• Ceiling grid system (if suspended)\n';
  list += '• Grid suspension hardware\n';
  list += '• Edge trim/molding\n';
  list += '• Safety equipment\n';
  list += '• Extra tiles (5-10% recommended)\n';

  list += '\n\nGenerated by Ceiling Tile Calculator\n';
  list += new Date().toLocaleDateString();

  return list;
}

export function downloadTextFile(content: string, filename: string): void {
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}